
# Generated by CodiumAI
import numpy as np
import softcam.domain.services.calculsdynamique as cdyn
import pytest

class Test_DynamiqueMvmtAffolement:

    # Test with typical values for all parameters to ensure correct beta_ddot calculation
    def test_typical_values(self):
        vbeta = np.array([np.pi/4, 1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Test with zero values for m1 or j2 to simulate division by zero or infinite results
    def test_zero_values(self):
        vbeta = np.array([np.pi/4, 1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 0.0  # Zero mass to check division by zero handling
        j2 = 0.0  # Zero moment of inertia to check division by zero handling
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        with pytest.raises(ZeroDivisionError):
            cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)

    # Check function behavior with positive and negative values of angular velocity
    def test_negative_angular_velocity(self):
        vbeta = np.array([np.pi/4, -1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Test with non-numeric inputs to confirm type checking and error handling
    def test_non_numeric_inputs(self):
        vbeta = ['a', 'b']  # Non-numeric inputs
        t = 'time'  # Non-numeric input
        m1 = 'mass'  # Non-numeric input
        j2 = 'inertia'  # Non-numeric input
        k = 'stiffness'  # Non-numeric input
        dr = 'damping'  # Non-numeric input
        l_ling = 'length'  # Non-numeric input
        r_ps = 'position'  # Non-numeric input
        z_l = 'position'  # Non-numeric input
        f_fs = 'force'  # Non-numeric input
        with pytest.raises(TypeError):
            cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)

    # Evaluate function's response to very high angular velocities to examine numerical stability
    def test_high_angular_velocities(self):
        vbeta = np.array([np.pi/2, 1000.0])  # High angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Validate function with zero initial angle and velocity to check for static equilibrium
    def test_static_equilibrium(self):
        vbeta = np.array([0.0, 0.0])  # Zero initial angle and velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Check behavior when f_fs is non-zero to ensure additional force factor is correctly integrated
    def test_behaviour_additional_force(self):
        vbeta = np.array([np.pi/3, 2.0])  # Angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.5
        j2 = 0.8
        k = 12.0
        dr = 0.2
        l_ling = 2.5
        r_ps = 0.1
        z_l = 0.3
        f_fs = 0.5
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Verify correct output shape and type (numpy array of floats)
    def test_correct_output_shape_and_type(self):
        vbeta = np.array([np.pi/4, 1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert isinstance(result, np.ndarray), "Output should be a numpy array"
        assert result.dtype == np.float64, "Elements in the array should be of type float"
        assert result.shape == (2,), "Output shape should be (2,)"

    # Input extreme values for k, dr, l_ling, r_ps, and z_l to test function stability under unusual conditions
    def test_extreme_values(self):
        vbeta = np.array([np.pi/4, 1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 1000000.0  # Extreme value for k
        dr = 1000000.0  # Extreme value for dr
        l_ling = 1000000.0  # Extreme value for l_ling
        r_ps = 1000000.0  # Extreme value for r_ps
        z_l = 1000000.0  # Extreme value for z_l
        f_fs = 0.0
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Provide negative values for l_ling, r_ps, and z_l to assess physical plausibility checks
    def test_negative_values_check(self):
        vbeta = np.array([np.pi/4, 1.0])  # Typical angle and angular velocity
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = -2.0
        r_ps = -0.05
        z_l = -0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"

    # Test with vbeta[0] close to +/- pi/2 to check for potential trigonometric singularities due to cos(vbeta[0]) approaching zero
    def test_trigonometric_singularities(self):
        vbeta = np.array([np.pi/2 - 1e-10, 1.0])  # Angle close to pi/2
        t = 0.0  # Time is not used in the function, but required by signature
        m1 = 1.0
        j2 = 0.5
        k = 10.0
        dr = 0.1
        l_ling = 2.0
        r_ps = 0.05
        z_l = 0.2
        f_fs = 0.3
        expected_beta_ddot = l_ling*np.cos(vbeta[0])/(j2 + m1*(l_ling*np.cos(vbeta[0]))**2)*(m1*l_ling*np.sin(vbeta[0])*vbeta[1]**2 - k*(l_ling*np.sin(vbeta[0])-z_l+r_ps+dr) - f_fs)
        result = cdyn.dynamique_mvmt_affolement(vbeta, t, m1, j2, k, dr, l_ling, r_ps, z_l, f_fs)
        assert np.isclose(result[1], expected_beta_ddot), f"Expected {expected_beta_ddot}, got {result[1]}"