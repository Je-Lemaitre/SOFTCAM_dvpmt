<!DOCTYPE html>
<html class="writer-html5" lang="fr" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>softcam.domain.services.calculsloiscame &mdash; Documentation softcam 2.0</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=e8570148"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/translations.js?v=041d0952"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Recherche" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            softcam
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" aria-label="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">softcam</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">softcam</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Code du module</a></li>
      <li class="breadcrumb-item active">softcam.domain.services.calculsloiscame</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Code source de softcam.domain.services.calculsloiscame</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">npl</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">scitp</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">scs</span>

<div class="viewcode-block" id="CalculRampe">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe">[docs]</a>
<span class="k">class</span> <span class="nc">CalculRampe</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CalculRampe modélise les lois de distribution pour les phases de rampe afin de pouvoir calculer la levée, la vitesse, l&#39;accélération et le jerk.</span>

<span class="sd">    Cette classe fournit des méthodes permettant le calcul de la levée et de ses dérivées au cours de la phase de rampe.</span>

<span class="sd">    Args:</span>
<span class="sd">        duree_rampe (float): Durée angulaire totale de la phase de rampe.</span>
<span class="sd">        duree_vitesse_constante (float): Durée angulaire de la sous-phase à vitesse constante dans la phase de rampe.</span>
<span class="sd">        levee_rampe (float): Levée caractéristique de la rampe.</span>
<span class="sd">        vitesse_rampe (float): Vitesse caractéristique de la rampe.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        dac_r (float): Durée de la phase de rampe.</span>
<span class="sd">        dac_vc (float): Durée de la phase à vitesse constante.</span>
<span class="sd">        dac_apos (float): Durée de la phase d&#39;accélération.</span>
<span class="sd">        lr (float): Levée caractéristique de la rampe.</span>
<span class="sd">        vr (float): Vitesse caractéristique de la rampe.</span>
<span class="sd">        la (float): Levée au début de la phase à vitesse constante.</span>
<span class="sd">        a7 (float), a6 (float), a5 (float), a4 (float): Coefficients du polynôme de degré 7 modélisant la phase d&#39;accélération en début de rampe.</span>

<span class="sd">    Methods:</span>
<span class="sd">        compute_coeffs_accel(): Calcule les coefficients du polynôme de degré 7 modélisant la levée pendant la phase d&#39;accéération en début de rampre.</span>
<span class="sd">        j(ac: float): Calcule le jerk pour la phase de rampe.</span>
<span class="sd">        a(ac: float): Calcule l&#39;accélération pour la phase de rampe.</span>
<span class="sd">        v(ac: float): Calcule la vitesse pour la phase de rampe.</span>
<span class="sd">        l(ac: float): Calcule la levée pour la phase de rampe.</span>
<span class="sd">        compute_levee_accel(): Calcule la levée en début de phase à vitesse constante.</span>
<span class="sd">        matrix_pb(): Génère la matrice du système d&#39;équations permettant la détermination de la phase d&#39;accélération en début de rampe.</span>
<span class="sd">        bcs_pb(): Génère le vecteur des conditions aux limites.</span>
<span class="sd">        from_dict(d: dict): Crée une instance de CalculRampe à partir d&#39;un dictionnaire.</span>
<span class="sd">        to_dict() -&gt; dict: Convertit l&#39;instance en dictionnaire.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Si certaines durées sont négatives ou nulles ou si la duree de rampe est inférieure à la durée à vitesse constante.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duree_rampe</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">duree_vitesse_constante</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">levee_rampe</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">vitesse_rampe</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">duree_rampe</span><span class="o">&lt;=</span><span class="mi">0</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La rampe a une durée nulle ou négative.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duree_vitesse_constante</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La phase à vitesse constante de la rampe à une durée nulle ou négative.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duree_rampe</span> <span class="o">&lt;</span> <span class="n">duree_vitesse_constante</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La durée de la phase à vitesse constante doit être inférieure à la durée de la phase de rampe.&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__dac_r</span> <span class="o">=</span> <span class="n">duree_rampe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dac_vc</span> <span class="o">=</span> <span class="n">duree_vitesse_constante</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dac_apos</span> <span class="o">=</span> <span class="n">duree_rampe</span> <span class="o">-</span> <span class="n">duree_vitesse_constante</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lr</span> <span class="o">=</span> <span class="n">levee_rampe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__vr</span> <span class="o">=</span> <span class="n">vitesse_rampe</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">__la</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_levee_accel</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__a7</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_coeffs_accel</span><span class="p">()</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dac_r</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dac_r</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dac_vc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dac_vc</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dac_apos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dac_apos</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lr</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">vr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__vr</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">la</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__la</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a7</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a7</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a6</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a6</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a5</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a5</span>        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a4</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a4</span>
    
<div class="viewcode-block" id="CalculRampe.compute_coeffs_accel">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.compute_coeffs_accel">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_coeffs_accel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcule les coefficients du polynôme de degré 7 qui modélise la levée pendant la phase d&#39;accélération des rampes d&#39;ouverture et de fermeture. </span>
<span class="sd">        </span>
<span class="sd">        Ce calcul revient à résoudre un système d&#39;équations linéaires d&#39;ordre 4. Cette résolution est ici présentée de façon matricielle.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Coefficients du polynôme de degré 7 modélisant la levée.</span>
<span class="sd">        </span>
<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Si la matrice du système d&#39;équation n&#39;est pas inversible, il n&#39;est pas possible de trouver des solutions. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">npl</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_pb</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mf">1e-5</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La matrice du problème est difficilement inversible. Il se peut que les solutions du problème n&#39;existent pas ou soient imprécises&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">npl</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_pb</span><span class="p">())</span><span class="nd">@self</span><span class="o">.</span><span class="n">bcs_pb</span><span class="p">()</span></div>


<div class="viewcode-block" id="CalculRampe.j">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.j">[docs]</a>
    <span class="k">def</span> <span class="nf">j</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcul du jerk spécifiquement pour la phase de rampe.</span>

<span class="sd">        Args:</span>
<span class="sd">            ac (numpy.ndarray): Angle de rotation de la came.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Jerk de la soupape (en m/rad^3).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">j_ar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">))))</span>
            <span class="n">jerk</span> <span class="o">=</span> <span class="mi">210</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a7</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">120</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a6</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">60</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a5</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">24</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="o">*</span><span class="n">xm</span>
            <span class="n">jerk</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">jerk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        
        <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">ac</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ac</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
        <span class="n">jerk</span> <span class="o">=</span> <span class="n">j_ar</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span>
        <span class="n">jerk</span><span class="p">[</span><span class="n">acm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">jerk</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span></div>


<div class="viewcode-block" id="CalculRampe.a">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.a">[docs]</a>
    <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcul de l&#39;accélération spécifiquement pour la phase de rampe.</span>

<span class="sd">        Args:</span>
<span class="sd">            ac (numpy.ndarray): Angle de rotation de la came.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Accélération de la soupape (en m/rad²).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">a_ar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">))))</span>
            <span class="n">accel</span> <span class="o">=</span> <span class="mi">42</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a7</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">30</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a6</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">20</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a5</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">12</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">accel</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">accel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        
        <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">ac</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ac</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
        <span class="n">accel</span> <span class="o">=</span> <span class="n">a_ar</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span>
        <span class="n">accel</span><span class="p">[</span><span class="n">acm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">accel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span></div>

            
<div class="viewcode-block" id="CalculRampe.v">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.v">[docs]</a>
    <span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcul de la vitesse spécifiquement pour la phase de rampe.</span>

<span class="sd">        La loi de vitesse est divisée en 2 phases, une accélération qui suit la loi donné par le polynôme et une phase à vitesse constante. deux fonctions sont définies pour pouvoir les calculer.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            ac (numpy.ndarray): Angle de rotation de la came.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Vitesse de la soupape (en m/rad).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">v_ar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">))))</span>
            <span class="n">vitesse</span> <span class="o">=</span> <span class="mi">7</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a7</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="mi">6</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a6</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a5</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">3</span>
            <span class="n">vitesse</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">vitesse</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        
        <span class="k">def</span> <span class="nf">v_vcr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
            <span class="n">vitesse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vr</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">xm</span>
            <span class="n">vitesse</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">vitesse</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        
        <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">ac</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ac</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
        <span class="n">vitesse</span> <span class="o">=</span> <span class="n">v_ar</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span> <span class="o">+</span> <span class="n">v_vcr</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span>
        <span class="n">vitesse</span><span class="p">[</span><span class="n">acm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">return</span> <span class="n">vitesse</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span></div>


<div class="viewcode-block" id="CalculRampe.l">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.l">[docs]</a>
    <span class="k">def</span> <span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ac</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcul de la levée spécifiquement pour la phase de rampe.</span>

<span class="sd">        La loi de levée est divisée en 2 phases, une accélération qui suit la loi donné par le polynôme et une phase affine. Deux fonctions distinctes sont donc définies pour pouvoir les calculer.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            ac (numpy.ndarray): Angle de rotation de la came.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Levée de la soupape (en m).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">l_ar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">))))</span>
            <span class="n">levee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a7</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">7</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a6</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">6</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a5</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">5</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">a4</span><span class="o">*</span><span class="n">xm</span><span class="o">**</span><span class="mi">4</span>
            <span class="n">levee</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">levee</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">def</span> <span class="nf">l_vcr</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">xm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
            <span class="n">levee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">*</span><span class="p">(</span><span class="n">xm</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">)</span>
            <span class="n">levee</span><span class="p">[</span><span class="n">xm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">levee</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">acm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">ac</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ac</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">))))</span>
        <span class="n">levee</span> <span class="o">=</span> <span class="n">l_ar</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span> <span class="o">+</span> <span class="n">l_vcr</span><span class="p">(</span><span class="n">acm</span><span class="p">)</span>
        <span class="n">levee</span><span class="p">[</span><span class="n">acm</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">levee</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span></div>

    
<div class="viewcode-block" id="CalculRampe.compute_levee_accel">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.compute_levee_accel">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_levee_accel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="n">levee_accel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">vr</span>
        <span class="k">if</span> <span class="n">levee_accel</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;La levée renseigné pour la rampe conduit à une levée négative. Afin de contrer ce problème vous pouvez au choix : </span><span class="se">\n</span><span class="s2"> </span><span class="se">\a</span><span class="s2">c Augmenter la levée de rampe </span><span class="se">\n</span><span class="s2"> </span><span class="se">\a</span><span class="s2">c Diminuer la vitesse de rampe </span><span class="se">\n</span><span class="s2"> </span><span class="se">\a</span><span class="s2">c Diminuer la durée de la phase à vitesse constante.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">levee_accel</span></div>

    
<div class="viewcode-block" id="CalculRampe.matrix_pb">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.matrix_pb">[docs]</a>
    <span class="k">def</span> <span class="nf">matrix_pb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Crée la matrice représentant le système linéaire représentant le problème.</span>

<span class="sd">        La matrice réduite est de dimension 4x4.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: La matrice 4x4 représentative du problème.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">7</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">42</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mi">30</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">210</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="mi">120</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">60</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="p">,</span> <span class="mi">24</span><span class="p">]</span>
        <span class="p">])</span></div>

    
<div class="viewcode-block" id="CalculRampe.bcs_pb">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.bcs_pb">[docs]</a>
    <span class="k">def</span> <span class="nf">bcs_pb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Crée le vecteur représentant les conditions aux limites du problème.</span>

<span class="sd">        Ce vecteur est un vecteur réduit aux coefficient qui ne sont pas nuls a priori.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray: Vecteur des conditions aux limites.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">la</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">4</span><span class="p">,</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">vr</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_apos</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="mi">0</span>
        <span class="p">])</span></div>

    
<div class="viewcode-block" id="CalculRampe.from_dict">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Crée une instance de la classe CalculRampe à partir d&#39;un dictionnaire contenant les attributs de la classe. </span>
<span class="sd">        </span>
<span class="sd">        Cette opération permet d&#39;importer une classe CalculRampe qui aurait été stockée au format .json.</span>

<span class="sd">        Args:</span>
<span class="sd">            dict: Dictionnaire dont les clés sont les attributs de la classe.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            CalculRampe: Une instance de la classe CalculRampe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="CalculRampe.to_dict">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRampe.to_dict">[docs]</a>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convertit les attributs de la classe en un dicitionnaire. </span>
<span class="sd">        </span>
<span class="sd">        Cette opération est nécessaire pour pouvoir stocker les données au format .json.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionnaire dont les clés sont les attributs de la classe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;duree_rampe&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_r</span><span class="p">,</span>
            <span class="s2">&quot;duree_vitesse_constante&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dac_vc</span><span class="p">,</span>
            <span class="s2">&quot;levee_rampe&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr</span><span class="p">,</span>
            <span class="s2">&quot;vitesse_rampe&quot;</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">vr</span>
        <span class="p">}</span></div>
</div>

    

<div class="viewcode-block" id="CalculRaccord">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord">[docs]</a>
<span class="k">class</span> <span class="nc">CalculRaccord</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utilitaire de calcul du raccord en accélération positive et limite de décélération à l&#39;affolement.</span>
<span class="sd">     </span>
<span class="sd">    Cette classe fournit des fonctions permettant de calculer la phase de raccord entre l&#39;accélération positive et la décélération à la limite de l&#39;affolement. Ce raccord est créé par une courbe de Bézier à trois points de contrôle. Le premier point de contrôle est le point de fin d&#39;accélération positive. Le second point de contrôle est le point au début de la phase de décélération à la limite de l&#39;affolement. Le dernier point de contrôle est l&#39;intersection des tangentes aux deux premiers points de contrôle.</span>

<span class="sd">    Args:</span>
<span class="sd">        duree_raccord (float): Durée du raccord, doit être positive.</span>
<span class="sd">        accel_init (float): Accélération en fin de phase d&#39;accélération positive.</span>
<span class="sd">        jerk_init (float): Jerk en fin de phase d&#39;accélération positive.</span>
<span class="sd">        accel_final (float): Accélération en début de phase de décélération à la limite de l&#39;affolement.</span>
<span class="sd">        jerk_final (float): Jerk en début de phase de décélération à la limite de l&#39;affolement.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        dac_raccord (float): Durée du raccord Duration of the connection, must be positive.</span>
<span class="sd">        ai (float): Accélération en fin de phase d&#39;accélération positive.</span>
<span class="sd">        ji (float): Jerk en fin de phase d&#39;accélération positive.</span>
<span class="sd">        af (float): Accélération en début de phase de décélération à la limite de l&#39;affolement.</span>
<span class="sd">        jf (float): Jerk en début de phase de décélération à la limite de l&#39;affolement.</span>
<span class="sd">        a_spl (scipy.interpolate.BSpline): Spline interpolant l&#39;accélération.</span>
<span class="sd">        v_spl (scipy.interpolate.BSpline): Spline interpolant la vitesse.</span>
<span class="sd">        l_spl (scipy.interpolate.BSpline): Spline interpolant la levée.</span>
<span class="sd">        j_spl (scipy.interpolate.BSpline): Spline interpolant le jerk.</span>

<span class="sd">    Methods:</span>
<span class="sd">        update(): Updates the attributes representing the interpolations of acceleration, velocity, lift, and jerk.</span>
<span class="sd">        compute_accel_spl() -&gt; scipy.interpolate.BSpline: Interpole l&#39;accélération par un BSpline.</span>
<span class="sd">        get_bezier_parameters(X, Y, degree=3): Calcule la relation entre l&#39;abscisse curviligne de la courbe de bézier et les coordonnées du point.</span>
<span class="sd">        bezier_curve(points: list, nTimes: int=50) -&gt; tuple[np.ndarray, np.ndarray]: Retourne la courbe de Bézier passant par les points de contrôle.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: Si la durée du raccord n&#39;est pas strictement positive.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">duree_raccord</span><span class="p">,</span> <span class="n">accel_init</span><span class="p">,</span> <span class="n">jerk_init</span><span class="p">,</span> <span class="n">accel_final</span><span class="p">,</span> <span class="n">jerk_final</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">duree_raccord</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Le raccord a une durée négative ou nulle ce qui n&#39;est pas permis.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__dac_raccord</span> <span class="o">=</span> <span class="n">duree_raccord</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ai</span> <span class="o">=</span> <span class="n">accel_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ji</span> <span class="o">=</span> <span class="n">jerk_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__af</span> <span class="o">=</span> <span class="n">accel_final</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__jf</span> <span class="o">=</span> <span class="n">jerk_final</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__a_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_accel_spl</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__v_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__l_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__j_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dac_raccord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dac_raccord</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ai</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ai</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ji</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ji</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">af</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__af</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">jf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__jf</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">a_spl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__a_spl</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">v_spl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__v_spl</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l_spl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__l_spl</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">j_spl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__j_spl</span>
    
    <span class="nd">@dac_raccord</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dac_raccord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_dac</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour la durée du raccord.</span>

<span class="sd">        Ce &quot;setter&quot; s&#39;assure en même temps que la dure du raccord est strictement positive. Et recalcule la spline représentant le raccord.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_dac: Nouvelle durée du raccord.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: Si la nouvelle durée n&#39;est pas strictement positive, la durée est considérée comme non valide.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_dac</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Le raccord a une durée négative ou nulle ce qui n&#39;est pas permis.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dac_raccord</span> <span class="o">=</span> <span class="n">new_dac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_accel_spl</span><span class="p">()</span>
    <span class="nd">@ai</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ai</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ai</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour l&#39;ordonnée (accélération) du premier point de contrôle.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_af: Nouvelle valeur d&#39;accélération.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ai</span> <span class="o">=</span> <span class="n">new_ai</span>
    <span class="nd">@ji</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ji</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_ji</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour la dérivée du premier point de contrôle.</span>
<span class="sd">        </span>
<span class="sd">        Ce &quot;setter&quot; s&#39;assure que cette dérivée n&#39;est pas égale à la dérivée du deuxième point de contrôle. Si c&#39;était le cas, les deux tangentes seraient parallèles et aucune intersection ne pourrait donc être trouvée.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_jf: Nouvelle valeur de la dérivée.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ZeroDivisionError: Si new_ji = jf. Cela signifierait que les tangentes sont parallèle et que aucune intersection n&#39;existe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_ji</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">jf</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Les tangentes sont parallèles. Aucune solution ne peut être trouvée pour le troisième point.&quot;</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__ji</span> <span class="o">=</span> <span class="n">new_ji</span>
    <span class="nd">@af</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">af</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_af</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour l&#39;ordonnée (accélération) du deuxième point de contrôle.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_af: Nouvelle valeur d&#39;accélération.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__af</span> <span class="o">=</span> <span class="n">new_af</span>
    <span class="nd">@jf</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">jf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_jf</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour la dérivée du deuxième point de contrôle.</span>
<span class="sd">        </span>
<span class="sd">        Ce &quot;setter&quot; s&#39;assure que cette dérivée n&#39;est pas égale à la dérivée du premier point de contrôle. Si c&#39;était le cas, les deux tangentes seraient parallèles et aucune intersection ne pourrait donc être trouvée.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_jf: Nouvelle valeur de la dérivée.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ZeroDivisionError: Si new_jf = ji. Cela signifierait que les tangentes sont parallèle et que aucune intersection n&#39;existe.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_jf</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ji</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Les tangentes sont parallèles. Aucune solution ne peut être trouvée pour le troisième point.&quot;</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__jf</span> <span class="o">=</span> <span class="n">new_jf</span>
   
<div class="viewcode-block" id="CalculRaccord.update">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.update">[docs]</a>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Met à jour les attributs représentant les interpolations de l&#39;accélération, de la vitesse, de la levée et du jerk.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__a_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_accel_spl</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__v_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__l_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">antiderivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__j_spl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_spl</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">nu</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="CalculRaccord.compute_accel_spl">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.compute_accel_spl">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_accel_spl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">scitp</span><span class="o">.</span><span class="n">BSpline</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpole l&#39;accélération en se basant sur la courbe de Bézier précédemment calculée.</span>

<span class="sd">        Returns:</span>
<span class="sd">            scipy.interpolate.BSpline: A B-spline représentant l&#39;accélération sur la phase de raccord.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac_int</span><span class="p">,</span> <span class="n">a_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_bezier_3rd_pts</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ai</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ji</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_raccord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jf</span><span class="p">)</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ai</span><span class="p">],[</span><span class="n">ac_int</span><span class="p">,</span> <span class="n">a_int</span><span class="p">],[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">dac_raccord</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">af</span><span class="p">]])</span> 
        <span class="n">ac_evalpts</span><span class="p">,</span> <span class="n">accel_evalpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bezier_curve</span><span class="p">(</span><span class="n">knots</span><span class="p">)</span>
        <span class="n">ind_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">ac_evalpts</span><span class="p">)</span>
        <span class="n">ac_evalpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">ac_evalpts</span><span class="p">,</span> <span class="n">ind_sort</span><span class="p">)</span>
        <span class="n">accel_evalpts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">accel_evalpts</span><span class="p">,</span> <span class="n">ind_sort</span><span class="p">)</span>
        <span class="n">knot_vector</span><span class="p">,</span><span class="n">coefficients</span><span class="p">,</span><span class="n">degree</span> <span class="o">=</span> <span class="n">scitp</span><span class="o">.</span><span class="n">splrep</span><span class="p">(</span><span class="n">ac_evalpts</span><span class="p">,</span> <span class="n">accel_evalpts</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">scitp</span><span class="o">.</span><span class="n">BSpline</span><span class="p">(</span><span class="n">knot_vector</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">extrapolate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="CalculRaccord.get_bezier_parameters">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.get_bezier_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">get_bezier_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">Y</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">degree</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Least square qbezier fit using penrose pseudoinverse.</span>

<span class="sd">        Parameters:</span>

<span class="sd">        X: array of x data.</span>
<span class="sd">        Y: array of y data. Y[0] is the y point for X[0].</span>
<span class="sd">        degree: degree of the Bézier curve. 2 for quadratic, 3 for cubic.</span>

<span class="sd">        Based on https://stackoverflow.com/questions/12643079/b%C3%A9zier-curve-fitting-with-scipy</span>
<span class="sd">        and probably on the 1998 thesis by Tim Andrew Pastva, &quot;Bézier Curve Fitting&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">degree</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;degree must be 1 or greater.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;X and Y must be of the same length.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There must be at least </span><span class="si">{</span><span class="n">degree</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s1"> points to &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;determine the parameters of a degree </span><span class="si">{</span><span class="n">degree</span><span class="si">}</span><span class="s1"> curve. &#39;</span>
                            <span class="sa">f</span><span class="s1">&#39;Got only </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="si">}</span><span class="s1"> points.&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">bpoly</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Bernstein polynomial when a = 0 and b = 1. &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">**</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">scs</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="c1">#return comb(n, i) * ( t**(n-i) ) * (1 - t)**i</span>

        <span class="k">def</span> <span class="nf">bmatrix</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Bernstein matrix for Bézier curves. &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">bpoly</span><span class="p">(</span><span class="n">degree</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">degree</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">T</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">least_square_fit</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
            <span class="n">M_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">pinv</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">M_</span> <span class="o">@</span> <span class="n">points</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">bmatrix</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)))</span>

        <span class="n">final</span> <span class="o">=</span> <span class="n">least_square_fit</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">final</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">final</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">final</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">final</span></div>


<div class="viewcode-block" id="CalculRaccord.bezier_curve">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.bezier_curve">[docs]</a>
    <span class="k">def</span> <span class="nf">bezier_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">nTimes</span><span class="p">:</span> <span class="nb">int</span><span class="o">=</span> <span class="mi">50</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a set of control points, return the</span>
<span class="sd">        bezier curve defined by the control points.</span>

<span class="sd">        points should be a list of lists, or list of tuples</span>
<span class="sd">        such as [ [1,1], </span>
<span class="sd">                    [2,3], </span>
<span class="sd">                    [4,5], ..[Xn, Yn] ]</span>
<span class="sd">            nTimes is the number of time steps, defaults to 1000</span>

<span class="sd">            See http://processingjs.nihongoresources.com/bezierinfo/</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nPoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">xPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
        <span class="n">yPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>

        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">nTimes</span><span class="p">)</span>

        <span class="n">polynomial_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">bernstein_poly</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nPoints</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPoints</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xPoints</span><span class="p">,</span> <span class="n">polynomial_array</span><span class="p">)</span>
        <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">yPoints</span><span class="p">,</span> <span class="n">polynomial_array</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span></div>


<div class="viewcode-block" id="CalculRaccord.compute_bezier_3rd_pts">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.compute_bezier_3rd_pts">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_bezier_3rd_pts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">j1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y2</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">j2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calcule les coordonées du 3ème point de controle de la courbe de Bézier. </span>
<span class="sd">        </span>
<span class="sd">        Cette fonction à pour objectif de calculer le troisième point de contrôle de la courbe de Bézier à partir des coordonnées de 2 points et de la valeur des dérivées en ces points. </span>
<span class="sd">        Le troisième point se trouve en fait à l&#39;intersection des tangentes aux deux autres points.</span>

<span class="sd">        Args:</span>
<span class="sd">            x1 (float): Abscisse du premier point.</span>
<span class="sd">            y1 (float): Ordonnée du premier point.</span>
<span class="sd">            j1 (float): Dérivée de la courbe au premier point.</span>
<span class="sd">            x2 (float): Abscisse du second point.</span>
<span class="sd">            y2 (float): Ordonnée du second point.</span>
<span class="sd">            j2 (float):  Dérivée de la courbe au second point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Abscisse du troisième point.</span>
<span class="sd">            float: Ordonnée du troisième point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">j1</span> <span class="o">==</span> <span class="n">j2</span> <span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">(</span><span class="s2">&quot;Les tangentes sont parallèles. Aucune solution ne peut être trouvée pour le troisième point.&quot;</span><span class="p">)</span>

        <span class="n">xnew</span> <span class="o">=</span> <span class="p">(</span><span class="n">j2</span><span class="o">*</span><span class="n">x2</span> <span class="o">-</span> <span class="n">j1</span><span class="o">*</span><span class="n">x1</span> <span class="o">-</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">j2</span><span class="o">-</span><span class="n">j1</span><span class="p">)</span> 
        <span class="k">return</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">j1</span><span class="o">*</span><span class="p">(</span><span class="n">xnew</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y1</span></div>


<div class="viewcode-block" id="CalculRaccord.bernstein_poly">
<a class="viewcode-back" href="../../../../softcam.domain.services.html#softcam.domain.services.calculsloiscame.CalculRaccord.bernstein_poly">[docs]</a>
    <span class="k">def</span> <span class="nf">bernstein_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Évalue en t le ième membre du polynôme de Bernstein d&#39;ordre n.</span>

<span class="sd">        Args :</span>
<span class="sd">            i (int): Indice du membre du polynôme de Bernstein à évaluer.</span>
<span class="sd">            n (int): Ordre du polynôme de Bernstein.</span>
<span class="sd">            t (float): Valeur en laquelle évaluer le polynôme.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: Valeur en t du ième membre du polynôme de Bernstein d&#39;ordre n.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">scs</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span> <span class="n">t</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="n">i</span></div>
</div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">raccord</span> <span class="o">=</span> <span class="n">CalculRaccord</span><span class="p">(</span><span class="n">duree_raccord</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">accel_init</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">jerk_init</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">accel_final</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">jerk_final</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
    
    <span class="n">control_points</span> <span class="o">=</span> <span class="n">raccord</span><span class="o">.</span><span class="n">get_bezier_parameters</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">degree</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Droits d'auteur 2024, Jérémy Lemaitre.</p>
  </div>

  Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    fourni par <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>